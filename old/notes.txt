from seapie import prompt
from seapie import remote_prompt


prompt()
remote_prompt(secret="wololoo :D", mode="host/client")


"""
normal debugging: use prompt.
remote debugging: deploy breakpoint to somewhere









notes:
remote host should fail after N incorrect passwords.
remote host should have option for time out.
ssh should be used to reach the remote host


dokumentoi että ei mielellään sudoa vaan least priviledge principle


from multiprocessing.connection import Client
address = ('localhost', 6000)
conn = Client(address, authkey=b'secret password')
conn.send('Hello')
conn.send('close')
conn.close()


from multiprocessing.connection import Listener
address = ('localhost', 6000)     # family is deduced to be 'AF_INET'
listener = Listener(address, authkey=b'secret password')
conn = listener.accept()
print('connection accepted from', listener.last_accepted)
while True:
    msg = conn.recv()
    # do something with msg
    if msg == 'close':
        conn.close()
        break
listener.close()


putki pitää kääriä SSL kerrokseen että ei voi eavesrop...
https://docs.python.org/3/library/ssl.html

jos forwattuja portteja niin localhostin kuuntelu ei pelasta.
"""


"""
hotkeyt ei tuu uutena ominaisuutena seapie inputtiin. tee mieluummin getchistä
paketti ja tunge se githubiin. kaiken mitä hotkeyllä voi tehdä voi tarjota
jonkin näköisen modaalin takan tai lisää !komentoja vaan.

killer feature on remote debugging ja bugfixit.

historia kysymykseen vastataan tarjomalla tapa tallentaa snippettejä.
ne kijoitetaan johonkin .seapie fileen ~ tai $HOME$ alle. varmaan joku
"currentuser" sijainti löytyy. !!os.path.expanduser("~")!!





yapdb

historian kelaamiselle oma komento kun hotkeyt ei voi toimia. snippettien lisäksi.

"""











old setup:
from distutils.core import setup
setup(
  name = 'seapie',
  packages = ['seapie'],
  version = '2.0.1',
  license='Unlicense',
  description = 'Seapie is easy to use python debugger',
  author = 'Markus Hirsimäki',
  author_email = 'hirsimaki.markus@gmail.com',
  url = 'https://github.com/hirsimaki-markus/SEAPIE',
  download_url = 'https://github.com/hirsimaki-markus/SEAPIE/archive/v2.0.tar.gz',
  keywords = ['debugger', 'seapie', 'interactive', 'injection', 'inject', 'repl', 'debg', 'exec'],
  install_requires=[],
  classifiers=[
    'Development Status :: 5 - Production/Stable',
    'Intended Audience :: Developers',
    'Topic :: Software Development :: Build Tools',
    'License :: Other/Proprietary License',
    'Programming Language :: Python :: 3.7',
  ],
)


old pkg-info
Metadata-Version: 2.0.1
Name: seapie
Version: 2.0.1
Summary: Seapie is easy to use python debugger
Home-page: https://github.com/hirsimaki-markus/SEAPIE
Author: Markus Hirsimäki
Author-email: hirsimaki.markus@gmail.com
License: Unlicense
Download-URL: https://github.com/hirsimaki-markus/SEAPIE/archive/v_2_0.tar.gz
Description: README.md
Keywords: debugger,seapie,interactive,injection,inject,repl,debug,exec
Platform: any
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Build Tools
Classifier: License :: Other/Proprietary License
Classifier: Programming Language :: Python :: 3.7













_Have you ever wanted to just open the normal interactive prompt inside of your program and then continue?_\
_Have you ever wanted to debug something without ton of print()s but builtin debugger seems too clumsy?_

_Me too. I also got solution for it below._

<img src="https://raw.githubusercontent.com/hirsimaki-markus/SEAPIE/master/images/SEAPIE.png" width="100" height="100"/>

# SEAPIE 2.0.1

<!-- generated with shields.io. colors: informational and brightgreen and lightgrey -->
<img src="./images/downloads.svg"> <img src="./images/dependencies.svg"> <img src="./images/license.svg"> <img src="./images/size.svg"> <img src="./images/first-release.svg"> <img src="./images/implementation.svg"> <img src="./images/python-ver.svg"> <img src="./images/version.svg">


```SEAPIE``` stands for Scope Escaping Arbitrary Python Injection Executor


## Installation
* Platform independent. Only requirement is CPython api. If you don't know what this is everything should likely work out of the box
* ```pip3 install seapie```
* or ```pip3 install https://github.com/hirsimaki-markus/SEAPIE/archive/master.zip```
* or clone master, cd master, and ```pip3 install .```
* and to uninstall ```pip3 uninstall seapie```


## Features
A picture tells more than thousands words. Internal !help shown below
![](https://raw.githubusercontent.com/hirsimaki-markus/SEAPIE/master/images/seapiehelp.png)

```import seapie;seapie.true_exec()``` is provided as interface to autoexecute of version 1.2


## Examples
* Start tracing or to just open interactive prompt: ```from seapie import seapie;seapie()``` and maybe enter ```!help```
* Breakpoint your currently onging tracing: step until next ```seapie()``` by using ```!run``` or whatever suits you
* Autoexecute stuff when opening the prompt: ```seapie(["print(123)", "!step", "!verbose", "!until 420"])```
![](https://raw.githubusercontent.com/hirsimaki-markus/SEAPIE/master/images/seapiegif.gif)


## Todo
* Fix know issues
* Add check for console width to make prettyprinting easier
* Add exit banner/message
* Create decorator for autotracing and excepting functions
* Test how seapie works in multithreaded and multiprocessing programs
* Remove unnecessary features
* Improve on how seapie is imported. Maybe remove singleton requirement.
* Send me email or any message anywhere if you have suggestions
* !r will uselessly stop in loops. Replace with stopping on seapie instead. Problem with catching StopIteration
* Maybe do something useful with ! and !!
* Improve exit and quit, add abilty to just kill the entire thing
* Show all local and globals from all scopes?
* Auo post mortem? Run until crash then trigger seapie?
* History file?
* Make !l and !g display only keys to avoid absolutely flooding the console. Maybe limit print size. Maybe autocomplete from locals. This is stateless unlike history.
* List comprehensions sometimes produce nameerror when referring to local variable. Ipython has the same behaviour, might be unable to fix this. Problem is that new closure is created with list comprehension. A bypass can be achieved with eval("[rules for i in range(3)]", locals()).
    * The problem occurs, for example, when trying to access nonglobal name like this [x[0] for i in x] when x was defined outside of interactive seapie session
    * "The runcode() method of InteractiveInterpreter in code.py uses the 'self.locals' dictionary as the 'globals' parameter of the invoked exec() function. And the do_interact() method of Pdb instantiates InteractiveInterpreter with 'locals' as a merge of the current frame's locals and globals dictionary. This explains why the interact command of pdb evaluates sucessfully the generator expression: the generator function object is evaluated by the interpreter in a frame where 'locals' is NULL (see fast_function() in ceval.c) and 'globals' includes now the debugged frame locals dictionary."
    * So a fix for this problem is to have the default() method of pdb be implemented in the same manner as do_interact() and the runcode() method of InteractiveInterpreter. The attached patch does this.
    * Fix could be for seapie to automagically inject new stuff into the exec namespace when the scope is list comprehension. Or maybe some flag to trigger this.
    * Or maybe do some rewriting and use the builtin code.InteractiveConsole.interact. Actually, scratch that. Cant change parent scope with this.
* Display traceback on seapie startup if there is traceback waiting for try, catch > seapie block
* Overzealous postmortem check (triggers on generator exception and whatnots?) could be causing this behaviour.

## Known issues
* Using arrow keys in seapie prompt might result in keycodes like ```^[[A``` being displayed. This should be fixed by also importing readline along with seapie ``import readline;import seapie;seapie.seapie()``

* ```import seapie;seapie.seapie(["plaintextstring"])``` seems to have side effect of setting ```__doc__``` to ```"plaintextstring"```. This should not be problem as autoexecuting just plain string is useless.

* !w can crash seapie in some situations
* Improve !w to show filename
* Triggering seapie in list comprehension causes incorrect behaviours. E.g. [seapie.seapie() for i in "a"]. Seems to trigger multiple seapie instances.
* The above applies to all generators probably
* Add step to line number

## Unlicensing
Distributed under [The Unlicense](https://choosealicense.com/licenses/unlicense/) <img src="./images/unlicense.png" width="12" height="12"/> by Markus Hirsimäki in 2019 and 2020


laita varoitus jos koodia ajetaan pienemmällä versiolla kuin 3.12 koska list comprehension muuttui silloin
3.13 annotation scope tuleeko tää sotkemaan jotain?

threading.settrace_all_threads() and threading.setprofile_all_threads() vois ehkä sallia sen että
toinen thread kuuntelee salaa sokettia ja random kohdassa aloittaa tracettamisen muualla

pep709 on se mistä roikkuu list comprehension ja pep669 on se mistä roikkuu tracetus

cv lätinää: ymmärrän miten jotku tosi detaili asiat niinku vaikka nää pepit mitkä tuli pari kk
sit vaikuttaa debuggeriin

itse asiassa sys.monitoring ei toimikkaan tähän tarkoitukseen kun ei saa frameja

mieti mitä kaikea kannattaa paljastaa seapien sisältä. funktiot ei toimi yksin.

kato se vanha readme että onko bugit korjattu mitä listattu

kerro sonjalle seapie

testaa tracettaa for looppiin ja generaattoriin.

salli autoexecute?

bangeille argumenttien validointi

dokumentoi että seapie yrittää piilottaa itsensä tracebakeistä mitä se printtaa
vaikka seapie asuukin samassa stakisa kuin kaikki muu. sys._getframe(0) on seapie eikä ohjelma.
taitaa olla 3 framea.

testaa saako tracetettua itsensä. jos saa niin
  # if frame.f_code.co_filename == inspect.getfile(
    #        Trace
    #    ):



!(f)rame              antaa referenssin frameen jota debugataan nyt. tai ehkä alin frame. frame globaaliin. ehkä id() mukaan mutta ei oo sama ku reprissä. meh. ja muistutus että del frame.
!(p)ickle <object>    pickle

!next !return !call   steppaa seuraavaan x asti?
!condition korvaamaan until?
!step
!step* 10
!step# 10
!step? <expression>

step tai until tms ottamaan filename arg?

status info funktio leikkaamaan jos ei mahdu terminaaliin

tee sittenkin oma input koska historia?



joskus tulevaisuudessa tai jätä ehkä todo: ! ja !! ja !!!        mitä nää tekee? ehkä sama kuin ipython _ ja __ ja ___ ?'




known issues: defining recursive functions only works in the global scope in the interpeter


dokumentoi että voit steppaa eri framessa kuin missä interpreter on. teet sillä sitten muutoksia mitä
et näe ennenkuin mene sinne alimpaan frameen.